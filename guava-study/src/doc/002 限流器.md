# 1.基本内容
1.  瞬时限流，即最大并发量的控制，可以用semaphore；而时段性控制并发量，则可以用RateLimiter
2.  

# 2.限流器
1.  RateLimiter听说是令牌桶，
    见这篇文章：https://dzone.com/articles/detailed-explanation-of-guava-ratelimiters-throttl
    中文翻译：https://zhuanlan.zhihu.com/p/60979444
    吐槽：翻译文章在参考文献中竟然不写出原文地址，着实让人气愤，我在评论区给出了，哈哈。
2.  下面是我的见解：
    1.  第一：RL不是令牌桶模型，是赊账模型，而且是只能不能重叠赊账（好借好还再借不难）—— 在每一个token点，只要当时没有未还清的账，就可以预支任意多个token。
    2.  第二：如果token的消费率不高时，是可以储存的，但是只能储存一秒的token量；储存起始点可以是任何还清账款的token点，然后累积token，到一秒的量，之后溢出。
3.  实现思路：
    1.  RL维护一个全局的时钟clock，记录下一个请求线程需要等待到的时间点——绝对时间，和当前系统会同步。
    2.  加入RL的token量是5，请求者（requester，简称r1）预支了5个token，则clock=1；
        1.  (欠款了)如果r2在（0-1）内，则r2就的等待直到1s。并且clock+=(1/5s)
        2.  (不欠款了)如果r2在[1,+00),则r2就不会等待，直接获取token。clock+=(n/5s)
    3.  所以，一个全局变量就搞定了；等等，不是字面上的全局变量，是大家共享这个变量的意思。

4.  RL的其他功能，都很简单了
    1.  预热功能，WarmingUp
    2.  带timeout的wait

5.  用处：
    

6.  扩展：
    1.  RL只能是单机的，要搞集群限流，则可以用Redis或者Sentinel(阿里的)
    
        
        

# 9.extension
1.  熔断和降级