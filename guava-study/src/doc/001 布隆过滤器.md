# 1.what is bloomFilter？

1.  首先它是个过滤器，而不是一个精准的辨别器（做到精准是很不划算的）
2.  它的不精准
    1.  被挡住的，就真的不存在
    2.  没有被挡住的，有可能是存在的——这就是不精准的部分，也叫做'假阳性'

# 2.布隆过滤器的催生的一条路线
    
1.  原始需求是10级别的数据量，判断一个元素是否存在；
2.  分析：
    1.  这世上没有比位更小的数据单位了，所以为了节约空间，必须这样用。
    2.  如果单纯的考虑10亿的exist判断，mysql的uk也可以，但是数据量太大，而且效率也因数据量巨大而显得慢
    3.  所以，对于这么大的数据量，其存储当然要用位，而其查询呢也只有hash了。
    4.  先算一下数据存储：10亿bit大概是1.16G，这么多数据可以加载到内存中，比如用redis呢
3.  哈希登场
    1.  哈先生来干什么？来把各种奇葩的元素映射成0-M的数据空间呀
    2.  有了这个映射在数据加载和数据查询时，就方便多了。
    3.  当然要保持数据查询时和数据加载的逻辑一样啦。不然还有什么exist可言。
    4.  bloomfilter中使用了多个哈希函数，来做处理冲突

4.  多哈希函数下的bloomfilter的插入和查询
    1.  首先声明：必须先把所有的数据加载到bloomfilter中。
        当然，如果伴随着数据从无到有的过程也是可以的，但这样就需要再有数据写入时，也要同步到bloomfilter，
        而且这有一个弊端：除此之外还必须提供数据全部加载的途径。
        这部分内容在下面有数据初始化时还会讲。
    2.  插入时，把h1(E)/h2(E)/h3(E)的位置都设为1；
        查找时，如果这三个位置有一个不是1的，那么Ex就不存在；如果都存在，则给通过，但是这是Ex其实不真的就存在的。
        我原本以为，我们需要的是它判定为不存在的功能，
        但其实我们更想要的是它那误判通过的不要太多，概率要小于1个点
        问题：这个概率是基于谁的？所有当前已知的元素吗？应该是，至少不会是基于那些无穷无尽的element空间。
    3.  这样一来，对于那些明显不属于有效element的，其通过率就大幅度下降到1个点，这对于防止缓存穿透攻击是很有效果的了。
    4.  OK，这样我们就引出了它的一个应用场景。
    5.  总结一句话：布隆是用来大幅度鉴别未知的。即判断NotExist的。
    6.  布隆和严格的鉴别器有多大的区别，可以混用吗？

5.  还有哪些应用场景
    1.  先说一句，布隆完全胜任的是"大幅度鉴别未知的"。如果反过来让它去鉴别已知，判断exist，那就有点不准了。不过也有这样用的
    2.  网页爬虫对url去重，避免爬取相同的url——判断exist，不准
    3.  反垃圾邮件，以数十亿的垃圾邮箱为依据，判断一个邮件是否来自垃圾邮箱——判断exist，也不准
    4.  Google Table使用布隆过滤器减少对不存在的行和列的查找——这个很应景
    5.  chrome识别恶意url

# 3.实现

1.  自己实现一套？不不，直接找现有的工具来用
2.  guava有，参见代码boolong.BloomFilterDemo
3.  缺点：guava是内存的，所以对应10亿的数量，在服务器上花费1G的内存，显然不明智，求助Redis
4.  求助Redis吧。比如：
    1.  [Redis 高级主题之布隆过滤器(BloomFilter)](https://juejin.im/post/5cfd060ee51d4556f76e8067)
    2.  [官网redis布隆过滤器](https://github.com/RedisBloom/RedisBloom#use-redisbloom-with-redis-cli)
    ps：原来redis还有模块功能呢，我竟然不知道；这种模块化——插件化，很想mysql的风格呢。



    
    


# extension
1.  各种散列函数的优劣？
2.  
